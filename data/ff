#ifndef myIOT2_h
#define myIOT2_h

#if defined(ESP8266)
#include <ESP8266WiFi.h>
#include <ESP8266mDNS.h> // OTA libraries
#include <TZ.h>

#elif defined(ESP32)
#include <WiFi.h>
#include <ESPmDNS.h> // OTA libraries
#define TZ_Asia_Jerusalem PSTR("IST-2IDT,M3.4.4/26,M10.5.0")
#endif

#include <WiFiUdp.h>      // OTA
#include <ArduinoOTA.h>   // OTA
#include <PubSubClient.h> // MQTT
#include <ArduinoJson.h>
#include <myJflash.h>
#include "secretsIOT.h"

#define MS2MINUTES 60000
#ifndef PRNT
#define PRNT(a)    \
    if (useSerial) \
    Serial.print(a)
#endif
#ifndef PRNTL
#define PRNTL(a)   \
    if (useSerial) \
    Serial.println(a)
#endif

class myIOT2
{
public:
    WiFiClient espClient;
    PubSubClient mqttClient;

    typedef void (*cb_func)(char *msg1, char *_topic);

protected:
    char ver[12] = "iot_v2.61";

public:                              /* ~~ These are must have topics, and order counts ~~ */
    const char *topics_pub[4]{};     /* myHome/DevName/Avail */
    const char *topics_sub[20]{};    /* myHome/DevName */
    const char *topics_gen_pub[4]{}; /* myHome/Messages; myHome/log; myHome/debug */
    const char *parameter_filenames[4]{};

    // ~~~~~~ Services ~~~~~~~~~
    bool useSerial = true;
    bool useFlashP = false;
    bool ignore_boot_msg = false;
    uint8_t noNetwork_reset = 4; // minutes
    // ~~~~~~~ end Services ~~~~~~~

    uint8_t num_p = 0;                  // number parameters got in MQTT message
    static const uint8_t num_param = 4; // max MQTT parameters
    const int mqtt_len = 300;
    char inline_param[num_param][20]; // values from user

    inline bool isWifiConnected() const { return _wifiConnected; };
    inline bool isMqttConnected() const { return _mqttConnected; };

private:
    char _ssid[15];
    char _wifi_pwd[15];
    char _mqtt_pwd[15];
    char _mqtt_user[15];
    char _mqtt_server[20];
    uint8_t _sub_topic_counter = 0;
    uint8_t _pub_topic_counter = 0;
    uint8_t _gen_topic_counter = 0;

    cb_func ext_mqtt;

    // time interval parameters
    const uint8_t OTA_upload_interval = 10; // minutes to try OTA
    unsigned long allowOTA_clock = 0;       // clock
    unsigned long _loop_period1_timeout = 0;       // for 5 minutes loop period

    bool _wifiConnected = false;
    bool _connectingToWifi = false;
    const uint8_t _retryConnectWiFi = 60; // seconds between fail Wifi reconnect reties
    unsigned long _lastWifiConnectiomAttemptMillis = 0;
    unsigned long _nextWifiConnectionAttemptMillis = 500;

    bool _mqttConnected = false;
    unsigned int _connectionEstablishedCount = 0; // Incremented before each _connectionEstablishedCallback call
    unsigned int _failedMQTTConnectionAttemptCount = 0;
    unsigned long _nextMqttConnectionAttemptMillis = 0;

    // holds status
    bool _firstRun = true;

    uint8_t _countCriteria;
    uint8_t bootcounter = 0;
    bool _rstSft_OK = false;
    bool _rstSft_Final = false;
    bool _use_rstSft = false;

public: /* Functions */
    myIOT2();
    void looper();
    void start_services(cb_func funct, const char *ssid = SSID_ID, const char *password = PASS_WIFI,
                        const char *mqtt_user = MQTT_USER, const char *mqtt_passw = MQTT_PASS, const char *mqtt_broker = MQTT_SERVER1);

    // ~~~~~~~ MQTT ~~~~~~~
    void strtClk_rstSft(uint8_t n = 3);
    bool getResult_rstStf();
    void loop_rstSft(uint8_t time_criteria = 15);
    void _write_rstSft(uint8_t value, const char *key = "counter", const char *fname = "/bootcounter.JSON");
    void _failure_rstSft();
    uint8_t _read_rstSft(const char *key = "counter", const char *fname = "/bootcounter.JSON");

    void notifyOnline();
    void pub_msg(const char *inmsg);
    void pub_log(const char *inmsg);
    void pub_debug(const char *inmsg);
    void sendReset(const char *header = nullptr);
    void pub_state(const char *inmsg, uint8_t i = 0);
    void pub_noTopic(const char *inmsg, const char *Topic, bool retain = false);

    // New add_topic functions
    void add_topic(const char *topic, const char *type);
    void add_topic(const char *topics[], uint8_t n, const char *type);

    // Backward compatibility functions
    void add_subTopic(const char *topic);
    void add_subTopic(const char *topics[], uint8_t n);
    void add_pubTopic(const char *topic);
    void add_pubTopic(const char *topics[], uint8_t n);
    void add_gen_pubTopic(const char *topic);
    void add_gen_pubTopic(const char *topics[], uint8_t n);

    // ~~~~~~~ Clk ~~~~~~~
    time_t now();
    void get_timeStamp(char ret[], time_t t = 0);
    void convert_epoch2clock(long t1, long t2, char time_str[], char days_str[] = nullptr);

    // ~~~~~~~ Param ~~~~~~~
    uint8_t inline_read(char *inputstr);
    void clear_inline_read();
    void set_pFilenames(const char *fileArray[], uint8_t asize);
    bool readFlashParameters(JsonDocument &DOC, const char *filename);
    bool readJson_inFlash(JsonDocument &DOC, const char *filename);

private:
    // ~~~~~~~WIFI ~~~~~~~
    void _startWifi(const char *ssid, const char *password);
    bool _startNTP(const char *ntpServer = "time.nist.gov", const char *ntpServer2 = "il.pool.ntp.org");
    bool _NTP_updated();
    bool _WiFi_handler();
    void _onWifiConnect();
    void _onWifiDisconnect();

    // ~~~~~~~ MQTT ~~~~~~~
    void _setMQTT();
    void _subMQTT();
    bool _connectMQTT();
    bool _MQTT_handler();
    void _concate(const char *array[], char outmsg[]);
    void _MQTTcb(char *topic, uint8_t *payload, unsigned int length);
    void _pub_generic(const char *topic, const char *inmsg, bool retain = false, char *devname = nullptr, bool bare = false);
    void _pub_succ_connectivity();

    // ~~~~~~~ OTA  ~~~~~~~
    void _startOTA();
    void _acceptOTA();

    // ~~~~~~~ Param ~~~~~~~
    uint8_t _getdataType(const char *y);
    bool _cmdline_flashUpdate(const char *key, const char *new_value);
    bool _change_flashP_value(const char *key, const char *new_value, JsonDocument &DOC);
    void _endRun_notofications();

    void _loop_period1();

    // Add the declaration of _add_topic
    void _add_topic(const char *topic, const char *type);
};
#endif





#include "myIOT2.h"

// ~~~~~~ myIOT2 CLASS ~~~~~~~~~~~ //
myIOT2::myIOT2() : mqttClient(espClient)
{
}
void myIOT2::start_services(cb_func funct, const char *ssid, const char *password,
							const char *mqtt_user, const char *mqtt_passw, const char *mqtt_broker)
{
	strcpy(_mqtt_server, mqtt_broker);
	strcpy(_mqtt_user, mqtt_user);
	strcpy(_mqtt_pwd, mqtt_passw);
	strcpy(_ssid, ssid);
	strcpy(_wifi_pwd, password);
	ext_mqtt = funct; // redirecting to ex-class function ( defined outside)

	if (useSerial)
	{
		Serial.begin(115200);
		PRNT(F("\n\n>>> ~~~~~~~ Start myIOT2 "));
		PRNT(ver);
		PRNTL(F(" ~~~~~~~ <<<"));
		delay(10);
	}

	_failure_rstSft(); // In case of boot error
	_setMQTT();
	_startNTP();
	_startOTA();
	_endRun_notofications();
}
void myIOT2::looper()
{
	if (_WiFi_handler())
	{
		return;
	}
	if (_MQTT_handler())
	{
		return;
	}
	if (_firstRun && _NTP_updated() == true && isMqttConnected())
	{
		_pub_succ_connectivity();
	}
	if (_use_rstSft)
	{
		loop_rstSft(); // Safety reset looper
	}
	_loop_period1();
}

// ~~~~~~~ Wifi functions ~~~~~~~
bool myIOT2::_WiFi_handler()
{
	/* First boot loop - reset the wifi radio and schedule the wifi connection */
	static bool firstLoopCall = true;
	if (firstLoopCall)
	{
		WiFi.disconnect(true);
		_nextWifiConnectionAttemptMillis = millis() + 500;
		firstLoopCall = false;
		PRNTL(F("~ WiFi Start services"));
		return true;
	}

	bool isWifiConnected = (WiFi.status() == WL_CONNECTED);

	/* After Wifi is connected for the first time - start connections sequence */
	if (isWifiConnected && !_wifiConnected /* updates after another succefull loop */)
	{
		_onWifiConnect();
		_connectingToWifi = false;
		_nextMqttConnectionAttemptMillis = millis() + 500; /* Better to have 500 millis delay */
	}

	/* Connection in progress - Wifi still not connected , timeout or wifi message */
	else if (_connectingToWifi)
	{
		if (WiFi.status() == WL_CONNECT_FAILED || millis() - _lastWifiConnectiomAttemptMillis >= _retryConnectWiFi * MS2MINUTES)
		{
			PRNTL("WiFi! Connection attempt failed, delay expired.");
			WiFi.disconnect(true);

			_nextWifiConnectionAttemptMillis = millis() + 500;
			_connectingToWifi = false;
		}
	}

	/* Connection lost - detection first time */
	else if (!isWifiConnected && _wifiConnected)
	{
		_onWifiDisconnect();
		_nextWifiConnectionAttemptMillis = millis() + 500;
	}

	// All is good - Connected since at least one loop() call
	else if (isWifiConnected && _wifiConnected)
	{
		_acceptOTA();
	}

	// Disconnected since at least one loop() call
	// Then, if we handle the wifi reconnection process and the waiting delay has expired, we connect to wifi
	/* Wifi is not connected, timeout trying to init Wifi connected */
	else if (_nextWifiConnectionAttemptMillis > 0 && millis() >= _nextWifiConnectionAttemptMillis)
	{
		_startWifi(_ssid, _wifi_pwd);
		_connectingToWifi = true;
		_nextWifiConnectionAttemptMillis = 0;
		_lastWifiConnectiomAttemptMillis = millis();
	}

	if (isWifiConnected != _wifiConnected)
	{
		_wifiConnected = isWifiConnected;
		return true;
	}
	else
	{
		return false;
	}
}
void myIOT2::_onWifiConnect()
{
	char b[50];
	sprintf(b, "\n~ Connected ,ip : %s", WiFi.localIP().toString().c_str());
	PRNTL(b);
}
void myIOT2::_onWifiDisconnect()
{
	PRNT(F("WiFi Lost connection "));
	PRNT(millis() / 1000);
	PRNTL(F("sec"));
}
void myIOT2::_startWifi(const char *ssid, const char *password)
{
	PRNTL(F("\n>>> WiFi <<<"));
	PRNT(F("~ Connecting to "));
	PRNT(ssid);

#if defined(ESP32)
	WiFi.useStaticBuffers(true);
#endif
	WiFi.mode(WIFI_STA);
	WiFi.begin(ssid, password);
}

// ~~~~~~~ NTP & Clock  ~~~~~~~~
bool myIOT2::_NTP_updated()
{
	return now() > 1640803233;
}
bool myIOT2::_startNTP(const char *ntpServer, const char *ntpServer2)
{
#if defined(ESP8266)
	configTime(TZ_Asia_Jerusalem, ntpServer2, ntpServer); // configuring time offset and an NTP server
#elif defined(ESP32)
	configTzTime(TZ_Asia_Jerusalem, ntpServer2, ntpServer);
#endif
	PRNTL(F("~ NTP and timezone set"));
	return 1;
}
void myIOT2::get_timeStamp(char ret[], time_t t)
{
	if (t == 0)
	{
		t = now();
	}
	struct tm *tm = localtime(&t);
	sprintf(ret, "%04d-%02d-%02d %02d:%02d:%02d", tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday, tm->tm_hour, tm->tm_min, tm->tm_sec);
}
void myIOT2::convert_epoch2clock(long t1, long t2, char time_str[], char days_str[])
{
	uint8_t days = 0;
	uint8_t hours = 0;
	uint8_t minutes = 0;
	uint8_t seconds = 0;

	const uint8_t sec2minutes = 60;
	const int sec2hours = (sec2minutes * 60);
	const int sec2days = (sec2hours * 24);

	long time_delta = t1 - t2;

	days = (int)(time_delta / sec2days);
	hours = (int)((time_delta - days * sec2days) / sec2hours);
	minutes = (int)((time_delta - days * sec2days - hours * sec2hours) / sec2minutes);
	seconds = (int)(time_delta - days * sec2days - hours * sec2hours - minutes * sec2minutes);
	if (days_str != nullptr)
	{
		sprintf(days_str, "%01dd", days);
	}
	sprintf(time_str, "%02d:%02d:%02d", hours, minutes, seconds);
}
time_t myIOT2::now()
{
	return time(nullptr);
}
void myIOT2::_loop_period1()
{
	if (millis() - _loop_period1_timeout > 5 * MS2MINUTES)
	{
		_loop_period1_timeout = millis();

		char msg[300];
		char IPadd[16];
		char days[10];
		char clock[25];
		char clock2[25];
		char newTopic[100];

		unsigned long t = (long)(millis() / 1000);
		get_timeStamp(clock2);
		convert_epoch2clock(t, 0, clock, days);
		sprintf(IPadd, "%d.%d.%d.%d", WiFi.localIP()[0], WiFi.localIP()[1], WiFi.localIP()[2], WiFi.localIP()[3]);
		sprintf(msg, "time[%s], uptime[%s %s], localIP[%s], MQTTserver[%s], RSSI: [%d dBm]",
				clock2, days, clock, IPadd, _mqtt_server, WiFi.RSSI());
		sprintf(newTopic, "%s/%s", topics_sub[0], "tele");
		pub_noTopic(msg, newTopic, true);
	}
}

// ~~~~~~~ MQTT functions ~~~~~~~
bool myIOT2::_MQTT_handler()
{
	unsigned int _mqttReconnectionAttemptDelay = 15 * 1000;

	mqttClient.loop();
	bool isMqttConnected = (isWifiConnected() && mqttClient.connected());

	// Connection re-established
	if (isMqttConnected && !_mqttConnected)
	{
		_mqttConnected = true;
		_subMQTT();
	}

	// Connection lost
	else if (!isMqttConnected && _mqttConnected)
	{
		PRNTL(F("MQTT: Retrying to connect"));
		_nextMqttConnectionAttemptMillis = millis() + _mqttReconnectionAttemptDelay;
	}

	// It's time to re-connect to the MQTT broker
	else if (isWifiConnected() && _nextMqttConnectionAttemptMillis > 0 && millis() >= _nextMqttConnectionAttemptMillis)
	{
		char b[50];
		if (_connectMQTT())
		{
			notifyOnline();
			if (!_firstRun)
			{
				sprintf(b, "MQTT: reconnect after [%d] retries", _failedMQTTConnectionAttemptCount);
				PRNTL(b);
				pub_log(b);
			}
			_failedMQTTConnectionAttemptCount = 0;
			_nextMqttConnectionAttemptMillis = 0;
		}
		else
		{
			_nextMqttConnectionAttemptMillis = millis() + _mqttReconnectionAttemptDelay;
			mqttClient.disconnect();
			_failedMQTTConnectionAttemptCount++;
			sprintf(b, "MQTT!: Failed MQTT connection count: %d", _failedMQTTConnectionAttemptCount);
			PRNTL(b);

			// When there is too many failed attempt, sometimes it help to reset the WiFi connection or to restart the board.
			if (_failedMQTTConnectionAttemptCount == 8)
			{
				PRNTL(F("MQTT: Can't connect to broker after too many attempt, resetting WiFi ..."));
				WiFi.disconnect(true);
				_nextWifiConnectionAttemptMillis = millis() + 500;

				if (!(noNetwork_reset > 0))
				{
					_failedMQTTConnectionAttemptCount = 0;
				}
			}
			else if (noNetwork_reset > 0 && _failedMQTTConnectionAttemptCount == 12) // Will reset after 12 failed attempt (3 minutes of retry)
			{
				PRNTL(F("MQTT!: Can't connect to broker after too many attempt, resetting board ..."));
				sendReset("MQTT failure");
			}
		}
	}

	if (_mqttConnected != isMqttConnected)
	{
		_mqttConnected = isMqttConnected;
		return true;
	}
	else
	{
		return false;
	}
}
void myIOT2::_setMQTT()
{
	mqttClient.setServer(_mqtt_server, 1883);
	mqttClient.setKeepAlive(30);
	mqttClient.setCallback(std::bind(&myIOT2::_MQTTcb, this, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3));
	PRNTL(F("~ MQTT broker set"));
}
bool myIOT2::_connectMQTT()
{
	char tempname[20];
#if defined(ESP8266)
	sprintf(tempname, "ESP_%s", String(ESP.getChipId()).c_str());
#elif defined(ESP32)
	uint64_t chipid = ESP.getEfuseMac();
	sprintf(tempname, "ESP32_%04X", (uint16_t)(chipid >> 32));
#endif
	PRNTL(F("\n>>> MQTT <<<"));
	if (mqttClient.connect(tempname, _mqtt_user, _mqtt_pwd, topics_pub[0], 1, true, "offline"))
	{
		PRNT(F("~ MQTT Server: "));
		PRNTL(_mqtt_server);
		return 1;
	}
	else
	{
		PRNT(F("~ Connection failed rc="));
		PRNTL(mqttClient.state());
		return 0;
	}
}
void myIOT2::_subMQTT()
{
	uint8_t m = sizeof(topics_sub) / sizeof(topics_sub[0]);
	PRNTL(F("~ MQTT server Connected"));
	PRNTL(F("\n~~ Subscribe Topics:"));
	PRNTL(F("±±±±±±±±±±±±±±±±±±±±±±±±±"));

	for (uint8_t i = 0; i < m; i++)
	{
		if (topics_sub[i] != nullptr)
		{
			mqttClient.subscribe(topics_sub[i]);
			PRNT(F("~ "));
			PRNTL(topics_sub[i]);
		}
	}
	PRNTL(F("±±±±±±±±±±±±±±±±±±±±±±±±±\n"));
}
void myIOT2::_concate(const char *array[], char outmsg[])
{
	uint8_t i = 0;
	while (array[i] != nullptr)
	{
		if (i > 0)
		{
			strcat(outmsg, "; ");
		}
		strcat(outmsg, array[i]);
		i++;
	}
	return;
}
void myIOT2::_pub_succ_connectivity()
{
	PRNTL(F(">>> ~~~~~~~ END iot2 ~~~~~~~ <<<"));
	char buf[10];
	char msg[100];
	dtostrf(millis() * 0.001, 5, 2, buf);
	sprintf(msg, "<< PowerON Boot >> IP:[%d.%d.%d.%d] RSSI [%d dB], boot duration: [%s sec]", WiFi.localIP()[0],
			WiFi.localIP()[1], WiFi.localIP()[2], WiFi.localIP()[3], WiFi.RSSI(), buf);
	if (!ignore_boot_msg)
	{
		pub_log(msg);
	}
	_firstRun = false;
}
void myIOT2::_MQTTcb(char *topic, uint8_t *payload, unsigned int length)
{
	char incoming_msg[30];
	char msg[200];

	PRNT(F("Message arrived ["));
	PRNT(topic);
	PRNT(F("] "));

	for (unsigned int i = 0; i < length; i++)
	{
		PRNT((char)payload[i]);
		incoming_msg[i] = (char)payload[i];
	}
	incoming_msg[length] = 0;
	PRNTL("");

	if (strcmp(incoming_msg, "ota") == 0)
	{
		sprintf(msg, "OTA allowed for %d seconds", OTA_upload_interval * MS2MINUTES / 1000);
		pub_msg(msg);
		allowOTA_clock = millis();
	}
	else if (strcmp(incoming_msg, "reset") == 0)
	{
		sendReset("MQTT");
	}
	else if (strcmp(incoming_msg, "ver") == 0)
	{
		sprintf(msg, "[ver]: IOTlib: [%s]", ver);
		pub_msg(msg);
	}
	else if (strcmp(incoming_msg, "services") == 0)
	{
		sprintf(msg, "[Services]: SERIAL[%s], no-networkReset[%d min], ignore_boot_msg[%s], useFlashP[%s]",
				useSerial ? "Yes" : "No", noNetwork_reset, ignore_boot_msg ? "Yes" : "No", useFlashP ? "Yes" : "No");
		pub_msg(msg);
	}
	else if (strcmp(incoming_msg, "help") == 0)
	{
		sprintf(msg, "[Help]: Commands #1 - [status, reset, ota, ver, ver2, help, help2, MCU_type, services, network]");
		pub_msg(msg);
		sprintf(msg, "[Help]: Commands #2 - [show_flashParam, free_mem, topics, {update_flash,[key],[value]}]");
		pub_msg(msg);
	}
	else if (strcmp(incoming_msg, "MCU_type") == 0)
	{
#if defined(ESP8266)
		sprintf(msg, "[MCU]: ESP8266");
#elif defined(ESP32)
		sprintf(msg, "[MCU]: ESP32");
#else
		sprintf(msg, "[MCU]: unKnown");
#endif
		pub_msg(msg);
	}
	else if (strcmp(incoming_msg, "show_flashParam") == 0)
	{
		if (useFlashP)
		{
			char clk[25];
			get_timeStamp(clk);
			sprintf(msg, "\n<<~~~~~~ [%s] [%s] On-Flash Parameters ~~~~~>>", clk, topics_sub[0]);
			pub_debug(msg);

			for (uint8_t i = 0; i < sizeof(parameter_filenames) / sizeof(parameter_filenames[0]); i++)
			{
				myJflash jf(useSerial);
				if (parameter_filenames[i] != nullptr)
				{
					jf.set_filename(parameter_filenames[i]);
					pub_debug(parameter_filenames[i]);
					String tempstr1 = jf.readFile2String(parameter_filenames[i]);
					char buff[tempstr1.length() + 1];
					tempstr1.toCharArray(buff, tempstr1.length() + 1);
					pub_debug(buff);
				}
			}
			pub_msg("[On-Flash Parameters]: extracted");
			pub_debug("<<~~~~~~~~~~ End ~~~~~~~~~~>>");
		}
		else
		{
			pub_msg("[On-Flash Parameters]: not in use");
		}
	}
	else if (strcmp(incoming_msg, "network") == 0)
	{
		char IPadd[16];
		char days[10];
		char clock[25];

		unsigned long t = (long)(millis() / 1000);
		convert_epoch2clock(t, 0, clock, days);
		sprintf(IPadd, "%d.%d.%d.%d", WiFi.localIP()[0], WiFi.localIP()[1], WiFi.localIP()[2], WiFi.localIP()[3]);
		sprintf(msg, "[Network]: uptime[%s %s], localIP[%s], MQTTserver[%s],  RSSI: [%d dBm]",
				days, clock, IPadd, _mqtt_server, WiFi.RSSI());

		pub_msg(msg);
	}
	else if (strcmp(incoming_msg, "free_mem") == 0)
	{
		float rmem;
		unsigned long fmem = ESP.getFreeHeap();
		char result[10];
		char result1[10];

#ifdef ESP8266
		rmem = 100 * (float)(fmem / (float)MAX_ESP8266_HEAP);
#endif
#ifdef ESP32
		rmem = 100 * (float)(fmem / (float)MAX_ESP32_HEAP);
#endif
		dtostrf(rmem, 6, 2, result);
		dtostrf(fmem / 1000.0, 6, 2, result1);
		sprintf(msg, "[Heap]: Remain [%skb] [%s%%]", result1, result);
		pub_msg(msg);
	}
	else if (strcmp(incoming_msg, "topics") == 0)
	{
		char A[100];

		strcpy(A, "");
		_concate(topics_pub, A);
		sprintf(msg, "[Pub_Topics]: %s", A);
		pub_msg(msg);

		strcpy(A, "");
		_concate(topics_sub, A);
		sprintf(msg, "[Sub_Topics]: %s", A);
		pub_msg(msg);

		strcpy(A, "");
		_concate(topics_gen_pub, A);
		sprintf(msg, "[gen-Pub_Topics]: %s", A);
		pub_msg(msg);
	}
	else
	{
		num_p = inline_read(incoming_msg);

		if (num_p > 1 && strcmp(inline_param[0], "update_flash") == 0 && useFlashP)
		{
			_cmdline_flashUpdate(inline_param[1], inline_param[2]);
		}
		else
		{
			ext_mqtt(incoming_msg, topic);
		}
	}
}
void myIOT2::_pub_generic(const char *topic, const char *inmsg, bool retain, char *devname, bool bare)
{
	const uint8_t mqtt_overhead_size = 23;
	const int mqtt_defsize = mqttClient.getBufferSize();

	int x = devname == nullptr ? strlen(topics_sub[0]) + 2 : 0;
	// int totl_len = strlen(inmsg) + x /* devTopic */+ 8 /* clock*/+ mqtt_overhead_size /* mqtt_overh*/ + 10 /*spare*/;
	// char tmpmsg[strlen(inmsg) + x + 8 + 25]; // avoid dynamic allocation
	char tmpmsg[mqtt_len];

	if (!bare)
	{
		char clk[25];
		get_timeStamp(clk, 0);
		snprintf(tmpmsg, mqtt_len, "[%s] [%s] %s", clk, topics_sub[0], inmsg);
	}
	else
	{
		snprintf(tmpmsg, mqtt_len, "%s", inmsg);
	}

	x = strlen(tmpmsg) + mqtt_overhead_size + strlen(topic); /* everything get into account when diff new buffer size*/
	if (x > mqtt_defsize)
	{
		mqttClient.setBufferSize(x);
		mqttClient.publish(topic, tmpmsg, retain);
		mqttClient.setBufferSize(mqtt_defsize);
	}
	else
	{
		mqttClient.publish(topic, tmpmsg, retain);
	}
}
void myIOT2::pub_msg(const char *inmsg)
{
	_pub_generic(topics_gen_pub[0], inmsg);
}
void myIOT2::pub_noTopic(const char *inmsg, const char *Topic, bool retain)
{
	_pub_generic(Topic, inmsg, retain, nullptr, true);
}
void myIOT2::pub_state(const char *inmsg, uint8_t i)
{
	if (i != 0)
	{
		int x = strlen(topics_pub[1]) + 3;
		char t[x];
		sprintf(t, "%s%d", topics_pub[1], i);
		mqttClient.publish(t, inmsg, true);
	}
	else
	{
		mqttClient.publish(topics_pub[1], inmsg, true);
	}
}
void myIOT2::pub_log(const char *inmsg)
{
	_pub_generic(topics_gen_pub[1], inmsg);
}
void myIOT2::pub_debug(const char *inmsg)
{
	_pub_generic(topics_gen_pub[2], inmsg, false, nullptr, true);
}
void myIOT2::add_topic(const char *topic, const char *type)
{
	_add_topic(topic, type);
}

void myIOT2::add_topic(const char *topics[], uint8_t n, const char *type)
{
	for (uint8_t i = 0; i < n; ++i)
	{
		_add_topic(topics[i], type);
	}
}
void myIOT2::_add_topic(const char *topic, const char *type)
{
	if (strcmp(type, "sub") == 0)
	{
		topics_sub[_sub_topic_counter++] = topic;
		Serial.println(type);
		Serial.flush();
	}
	else if (strcmp(type, "pub") == 0)
	{
		topics_pub[_pub_topic_counter++] = topic;
		Serial.println(type);
		Serial.flush();
	}
	else if (strcmp(type, "gen_pub") == 0)
	{
		topics_gen_pub[_gen_topic_counter++] = topic;
		Serial.println(type);
		Serial.flush();
	}
	else
	{
		Serial.println("Error: topic type not recognized");
	}
	// Serial.println(topic);	// Debug
	// Serial.println(type);	// Debug
}

void myIOT2::add_subTopic(const char *topic)
{
	add_topic(topic, "sub");
}
void myIOT2::add_subTopic(const char *topics[], uint8_t n)
{
	add_topic(topics, n, "sub");
}

void myIOT2::add_pubTopic(const char *topic)
{
	add_topic(topic, "pub");
}
void myIOT2::add_pubTopic(const char *topics[], uint8_t n)
{
	add_topic(topics, n, "pub");
}
void myIOT2::add_gen_pubTopic(const char *topic)
{
	add_topic(topic, "gen_pub");
}

void myIOT2::add_gen_pubTopic(const char *topics[], uint8_t n)
{
	add_topic(topics, n, "gen_pub");
}

void myIOT2::notifyOnline()
{
	mqttClient.publish(topics_pub[0], "online", true);
}
void myIOT2::clear_inline_read()
{
	for (uint8_t i = 0; i < num_p; i++)
	{
		strcpy(inline_param[i], "");
	}
}
uint8_t myIOT2::inline_read(char *inputstr)
{
	char *pch;
	int i = 0;

	pch = strtok(inputstr, " ,.-");
	while (pch != NULL && i < num_param)
	{
		sprintf(inline_param[i], "%s", pch);
		pch = strtok(NULL, " ,.-");
		i++;
	}
	return i;
}
uint8_t myIOT2::_getdataType(const char *y)
{
	/* Return values:
	0 - error
	1 - bool
	2 - string
	3 - float
	4 - int
	*/

	int i = atoi(y);
	float f = atof(y);

	if (isAlpha(y[0]))
	{
		if (strcmp(y, "true") == 0 || strcmp(y, "false") == 0)
		{
			return 1;
		}
		else
		{
			return 2;
		}
		return 0;
	}
	else
	{
		if (i != f)
		{
			return 3;
		}
		else
		{
			return 4;
		}
		return 0;
	}
}

// ~~~~~~~~~~ Data Storage ~~~~~~~~~
void myIOT2::set_pFilenames(const char *fileArray[], uint8_t asize)
{
	for (uint8_t i = 0; i < asize; i++)
	{
		parameter_filenames[i] = fileArray[i];
	}
}
bool myIOT2::readJson_inFlash(JsonDocument &DOC, const char *filename)
{
	myJflash Jflash(useSerial);
	return (Jflash.readFile(DOC, filename));
}
bool myIOT2::readFlashParameters(JsonDocument &DOC, const char *filename)
{
	if (readJson_inFlash(DOC, filename))
	{
		useSerial = DOC["useSerial"];
		useFlashP = true;
		noNetwork_reset = DOC["noNetwork_reset"];
		ignore_boot_msg = DOC["ignore_boot_msg"];
		PRNTL(F("~ iot2 Parameters loaded from Flash"));
		return 1;
	}
	else
	{
		useSerial = true;
		useFlashP = false;
		noNetwork_reset = 9;
		ignore_boot_msg = false;
		PRNTL(F("~ iot2 Parameters failed to load from Flash. Defaults are used"));
		return 0;
	}
}

bool myIOT2::_change_flashP_value(const char *key, const char *new_value, JsonDocument &DOC)
{
	uint8_t s = _getdataType(new_value);
	if (s == 1)
	{
		if (strcmp(new_value, "true") == 0)
		{
			DOC[key] = true;
		}
		else
		{
			DOC[key] = false;
		}
		return 1;
	}
	else if (s == 2)
	{
		DOC[key] = new_value;
		return 1;
	}
	else if (s == 3)
	{
		DOC[key] = (float)atof(new_value);
		return 1;
	}
	else if (s == 4)
	{
		DOC[key] = (int)atoi(new_value);
		return 1;
	}
	return 0;
}
bool myIOT2::_cmdline_flashUpdate(const char *key, const char *new_value)
{
	char msg[100];
	bool succ_chg = false;
	DynamicJsonDocument myIOT_P(1250); //<------------------ FIX THIS -----------

	myJflash Jflash(useSerial);
	for (uint8_t n = 0; n < sizeof(parameter_filenames) / sizeof(parameter_filenames[0]); n++)
	{
		if (Jflash.readFile(myIOT_P, parameter_filenames[n]))
		{
			if (myIOT_P.containsKey(key))
			{
				if (_change_flashP_value(key, new_value, myIOT_P))
				{
					if (Jflash.writeFile(myIOT_P, parameter_filenames[n]))
					{
						succ_chg = true;
						sprintf(msg, "[Flash]: parameter[%s] updated to[%s] [OK]", key, new_value);
					}
					else
					{
						succ_chg = false;
						sprintf(msg, "[Flash]: parameter[%s] [Failed] to updated. Save file error", key);
					}
				}
				else
				{
					succ_chg = false;
					sprintf(msg, "[Flash]: parameter[%s] replace [Failed]", key);
				}
				pub_msg(msg);
			}
		}
		else if (n == 1)
		{
			succ_chg = false;
			sprintf(msg, "[Flash]: parameter[%s] [NOT FOUND]", key);
			pub_msg(msg);
		}
	}
	return succ_chg;
}

// ~~~~~~ Reset and maintability ~~~~~~
void myIOT2::sendReset(const char *header)
{
	char temp[20 + strlen(header)];

	sprintf(temp, "[%s] - Reset sent", header);
	PRNTL(temp);

	if (header != nullptr)
	{
		pub_msg(temp);
	}
	delay(1000);
#if defined(ESP8266)
	ESP.reset();
#elif defined(ESP32)
	ESP.restart();
#endif
}
void myIOT2::_acceptOTA()
{
	if (millis() - allowOTA_clock <= OTA_upload_interval * MS2MINUTES)
	{
		ArduinoOTA.handle();
	}
}
void myIOT2::_startOTA()
{
	allowOTA_clock = millis();
	// ArduinoOTA.setPort(8266); default port is 3232. 8266 was on ArduinoIDE
	ArduinoOTA.setHostname(topics_sub[0]);
	ArduinoOTA.onStart([]()
					   {
						   String type;
						   if (ArduinoOTA.getCommand() == U_FLASH)
						   {
							   type = "sketch";
						   }
						   else
						   {
							   type = "filesystem";
						   } });
	if (useSerial)
	{
		ArduinoOTA.onEnd([]()
						 { Serial.println("\nEnd"); });
		ArduinoOTA.onProgress([](unsigned int progress, unsigned int total)
							  { Serial.printf("Progress: %u%%\r", (progress / (total / 100))); });
		ArduinoOTA.onError([](ota_error_t error)
						   {
							   Serial.printf("Error[%u]: ", error);
							   if (error == OTA_AUTH_ERROR)
							   {
								   Serial.println("Auth Failed");
							   }
							   else if (error == OTA_BEGIN_ERROR)
							   {
								   Serial.println("Begin Failed");
							   }
							   else if (error == OTA_CONNECT_ERROR)
							   {
								   Serial.println("Connect Failed");
							   }
							   else if (error == OTA_RECEIVE_ERROR)
							   {
								   Serial.println("Receive Failed");
							   }
							   else if (error == OTA_END_ERROR)
							   {
								   Serial.println("End Failed");
							   } });
	}

	ArduinoOTA.begin();
	PRNTL(F("~ OTA set"));
}
void myIOT2::_endRun_notofications()
{
	PRNTL(F("\n>>> Parameters <<<"));
	PRNT(F("useSerial:\t\t"));
	PRNTL(useSerial ? "Yes" : "No");

	PRNT(F("ignore_boot_msg:\t"));
	PRNTL(ignore_boot_msg ? "Yes" : "No");
	PRNT(F("useFlashP:\t\t"));
	PRNTL(useFlashP ? "Yes" : "No");
	PRNT(F("noNetwork_reset:\t"));
	PRNTL(noNetwork_reset);
	PRNT(F("ESP type:\t\t"));

	char a[10];
#if defined(ESP8266)
	strcpy(a, "ESP8266");
#elif defined(ESP32)
	strcpy(a, "ESP32");
#endif
	PRNTL(a);
	PRNT(F("Use Reset_Safety:\t"));
	PRNTL(_use_rstSft ? "Yes" : "No");
	if (_use_rstSft)
	{
		PRNT(F("Reset_Safety Counter:\t"));
		PRNTL(this->bootcounter);
		PRNT(F("Reset_Safety Boot-Mode:\t"));
		PRNTL(getResult_rstStf() ? "Normal" : "Failure");
	}

	PRNTL(F(">>> END <<<\n"));
}
void myIOT2::strtClk_rstSft(uint8_t n)
{
	_use_rstSft = true;
	this->_countCriteria = n;
	this->bootcounter = _read_rstSft();
	if (this->bootcounter < this->_countCriteria)
	{
		_rstSft_OK = true;
	}
	_write_rstSft(++this->bootcounter);
}
bool myIOT2::getResult_rstStf()
{
	return this->bootcounter < this->_countCriteria;
}
void myIOT2::loop_rstSft(uint8_t time_criteria)
{
	if (millis() > time_criteria * 1000 && this->bootcounter != 0)
	{
		_write_rstSft(0);
		this->bootcounter = 0;
		_rstSft_OK = true;
		PRNTL(F("Rest_Safety Reset"));
	}
}
void myIOT2::_write_rstSft(uint8_t value, const char *key, const char *fname)
{
	StaticJsonDocument<100> doc;
	myJflash bootCounter(this->useSerial);

	doc[key] = value;
	bootCounter.writeFile(doc, fname);
}
uint8_t myIOT2::_read_rstSft(const char *key, const char *fname)
{
	StaticJsonDocument<100> doc;
	myJflash bootCounter(this->useSerial);

	bootCounter.readFile(doc, fname);
	this->bootcounter = doc[key].as<uint8_t>();
	return this->bootcounter;
}
void myIOT2::_failure_rstSft()
{
	if (!getResult_rstStf() && _use_rstSft)
	{
		char temp2[40];
		char tempname[20];
		_sub_topic_counter = 0;
		_pub_topic_counter = 0;
		_gen_topic_counter = 0;

#if defined(ESP8266)
		sprintf(tempname, "ESP_%s", String(ESP.getChipId()).c_str());
#elif defined(ESP32)
		uint64_t chipid = ESP.getEfuseMac();
		sprintf(tempname, "ESP32_%04X", (uint16_t)(chipid >> 32));
#endif

		add_gen_pubTopic("myIOT/Messages");
		add_gen_pubTopic("myIOT/log");

		sprintf(temp2, "myIOT/%s", tempname);
		add_subTopic(temp2);
		add_subTopic("myIOT/All");
		sprintf(temp2, "myIOT/%s/Avail", tempname);

		add_pubTopic(temp2);
	}
}